/* 
 This file was generated by Dashcode and is covered by the 
 license.txt included in the project.  You may edit this file, 
 however it is recommended to first turn off the Dashcode 
 code generator otherwise the changes will be lost.
 */

// Note: Properties and methods beginning with underbar ("_") are considered private and subject to change in future Dashcode releases.

/*jsl:import DashcodePart.js*/

/**   
 *  @declare DC.List
 *  @extends DC.DashcodePart
 *  
 */

// Public properties:
//     element: the List's DOM element (read-only)
//     templateRowElement: the List's template row, the element that will be cloned to form the rows of the List
//     dataSource: for dynamic Lists, the dataSource object
//     dataArray: for static Lists, the static list data
//     rows: the current row elements for the list (read-only)
//     selectionIndexes: array of row indexes currently selected
//     selectedObject: object value of the first selected row 
//
// Public Methods:
//     selectionIndexes(): returns an array with the indexes of the selected rows
//     setSelectionIndexes(array, animated): set the selection row indexes, highlighting the selected rows. If 'animated' is true, the selection highlight will fade in/out.
//     setDataSource(dataSource): set the List to be dynamic, using the given dataSource (will reload the list)
//     setDataArray(array): set the List to be static, using the given data.  The array should be like [[row0Label, row0Value], [row1Label, row1Value], ...].
//     reloadData(): causes the List to reload itself.  Mostly useful for dynamic Lists when you know the data has changed and need the List to show the updated data.
//     setSelectionEnabled(newValue): set if the rows of the list can be selected..
//     setAllowsMultipleSelection(newValue): set if the list allows multiple selection.
//     setAllowsEmptySelection(newValue): set if there can be no row selected at any time.
//     setUseAlternatingRows(boolean): set if the list uses alternating background for rows.

//
// Row objects: (Each instantiated row has an "object" property.  Those objects have the following properties.)
//     rowIndex: the index of the row within the List
//     value: the value of the row (only for static Lists)
//     templateElements: a dictionary mapping original element ids from the template row element to the corresponding clones in this row

DC.List= Class.create(DC.ListView, {
    __viewClassName__: "DashcodeList",
	selectsInsertedItems: false,
    maskedBindings: ["content","selectionIndexes","selectedIndex","selectedObject"],
    exposedBindings: ["dataArray"],
					
    partSetup: function(spec)
    {
        // Backwards compatibility (this.viewElement() does the same thing)
        this.element = this.viewElement();
        
        try {
            this._listStyle = eval(spec.listStyle);
        } catch (e) {
            this._listStyle = this.EDGE_TO_EDGE;
        }

        this._selectionEnabled = spec.selectionEnabled || false;
        this.setAllowsEmptySelection(spec.allowsEmptySelection || false);
        this.setAllowsMultipleSelection(spec.allowsMultipleSelection || false);
        this._labelElementId = spec.labelElementId || 'label';

        this.setUseAlternatingRows(spec.useAlternatingRows || false);
				 
        var dataArray = spec.dataArray || null;
        var dataSourceName = spec.dataSourceName || null;
        
        this._useDataSource = spec.useDataSource || false;
        this._sampleRows = spec.sampleRows || 0;
        
        // When using this part inside a list template row, preserve ids temporarily
        spec.preserveChildIdsWhenCloning = true;
        
        // Set up the highlight element
        if (!dashcode.inDesign){
            this._rowHighlight = document.createElement("div");
            this._rowHighlight.className = "DC_selectionBG";
            this._rowHighlight.style.position = "absolute";
            this._rowHighlight.style.right = "0";
            this._rowHighlight.style.left = "0";
            this._rowHighlight.style.top = "0";
            this._rowHighlight.style.bottom = "0";
        } else {
            this.maximumCachedRows = 0;
        }
        
        // determine where to get the data from
        if (this._useDataSource) {
            var dataSource = window[dataSourceName];
            if (dataSource) {
                this.dataSource = dataSource;
            }
        } else if (dataArray) {
            var self = this;
            this.dataArray = dataArray;
        }
        
        this.viewElement().style.display = "block";
        
        this.selectedIndex = null;
        
        this.rows = [];
    },
    
    init: function(){
        this.base();
        
        // The super class already has the template element
        this.templateRowElement = this.templateElement;
        
        if (dashcode.inDesign && this.templateElement) {
            this.reloadData();
        }
    },
    clonedFrom: function(originalView){
        this.base(originalView);
        
        if (dashcode.inDesign) {
            this.templateElement = Element.clone(this.templateElement);
        }
        this.reloadData();
    },
	
    //
    // Set the data source object that will insert the data and format each row for dynamic lists.
    // dataSource must implement two required callback methods: numberOfRows() and prepareRow(rowElement, rowIndex, templateElements).
    // dataSource.numberOfRows() is called while the list is initializing and it should return the total number of rows in the list.
    // dataSource.prepareRow() is called once for each row. It is passed 3 parameters:
    //     rowElement: The HTML DOM element that represents the row being prepared. Typically an <li> element.
    //     rowIndex: The position of the row in the list, starting at 0.
    //     templateElements: A JavaScript object that contains a reference to each cloned element that had an ID in the template row. For example, if the template row had an element with id="label", the cloned element can be obtained using templateElements.label. These elements are descendants of rowElement.
    //
    setDataSource: function(dataSource)
    {
        this._useDataSource = true;
        this.dataSource = dataSource;
        this.reloadData();
    },
    
    observeDataArrayChange: function(change)
    {
        if (change.changeType == DC.ChangeType.setting) {
            var builtInAC = this._builtInArrayController(true);
            
            if (builtInAC){
                if (!builtInAC.bindings.arrangedObjects) {
                    if (builtInAC.bindings.content) {
                        builtInAC.bindings.content.unbind();
                    }
                    this.bindNameToKeyPath("content","*.arrangedObjects", this._builtInAC);
                }
                
                builtInAC.setValueForKey(change.newValue,"content");
                    
                /*
                // If we have a set value and we don't allow empty selection
                // ensure selection
                if (change.newValue && !this.getAllowsEmptySelection() && this.getSelectionEnabled() && !dashcode.inDesign) {
                    if (builtInAC.selectionIndex() == -1) {
                        builtInAC.setSelectionIndex(0);
                    }
                }
                */
            }
        }
    },
        
    //
    // Set the data array to use in static lists.
    // dataArray should be an Array of HTML strings and a row will be created for each item. The HTML string will be inserted as the innerHTML of the element with the ID specified in the part spec as labelElementId.
    //
    setDataArray: function(dataArray)
    {
        this._useDataSource = false;
        this.dataArray = dataArray;
        this.reloadData();
    },
    
    //
    // Get/set if selection is enabled for this list
    // The default is true
    //
    getSelectionEnabled: function()
    {
        return this._selectionEnabled;
    },
    setSelectionEnabled: function(newValue)
    {
        this._selectionEnabled = newValue;
        
        var builtInAC = this._builtInArrayController(false);
        
        if (builtInAC) {
            builtInAC.setAvoidsEmptySelection(!this.allowsEmpty && this._selectionEnabled && !dashcode.inDesign);
        }

    },

    //
    // Get/set if the list allows multiple selection
    // The default is false
    // This value is ignored if selectionEnabled is false
    //
    getAllowsMultipleSelection: function()
    {
        return this.multiple;
    },
    setAllowsMultipleSelection: function(newValue)
    {
        this.multiple = newValue;
    },

    //
    // Get/set if the list allows empty selection
    // The default is true
    // This value is ignored if selectionEnabled is false
    //
    getAllowsEmptySelection: function()
    {
        return this.allowsEmpty;
    },
    setAllowsEmptySelection: function(newValue)
    {
        this.allowsEmpty = newValue;
        
        var builtInAC = this._builtInArrayController(false);
        
        if (builtInAC) {
            builtInAC.setAvoidsEmptySelection(!this.allowsEmpty && this._selectionEnabled && !dashcode.inDesign);
        }

    },
 
   
    //
    // Get/set if the list uses alternating background for rows.
    // The default is true.
    //
    getUseAlternatingRows: function(){
        return this._useAlternatingRows;
    },
    setUseAlternatingRows: function(flag){
        this._useAlternatingRows = flag;
        
        if(flag)
            Element.addClassName(this.viewElement(), "useAlternatingRows");
        else
            Element.removeClassName(this.viewElement(), "useAlternatingRows");
    },


    //
    // This function is called by setupParts after all the parts have been set up.  
    // We do not initially load our data until all setup is complete.
    //
    finishLoading: function()
    {
        this.reloadData();
    },
    
    //
    // Reload the data from the data source (for dynamic lists) or from the data array (for static lists).
    // The list is regenerated by removing all the rows and cloning the template row. Parts inside each cloned row are also initialized.
    //
    reloadData: function()
    {
        // Prevent any problems with a real binding to the list
        if (!this._builtInAC && this.bindings && this.bindings.content)
            return;
        
        // If we have a binding on the data array, we aren't consulted
        if (this.bindings && this.bindings.dataArray)
            return;

        this.rows = [];
        this._anchorIndex = null;
                
        var builtInArrayController = this._builtInArrayController(true);
        var generatedData = DC.KVO.adaptTree([]);
        
        if (!builtInArrayController) {
            console.error("error generating built in array controller");
            return;
        }
        
        if (!builtInArrayController.bindings.content) {
            if (builtInArrayController.bindings.arrangedObjects) {
                builtInArrayController.bindings.arrangedObjects.unbind();
            }
            this.bindNameToKeyPath("content","*.arrangedObjects", builtInArrayController);
        }

        builtInArrayController.setValueForKey(generatedData,"content");            
        
        if(this._useDataSource && dashcode.inDesign){
            // Loop through and create an entry for each row
            for (var rowIndex=0; rowIndex<this._sampleRows; rowIndex++) {
                generatedData.addObject(DC.KVO.adapt({index:rowIndex}));        
            }
        } else if (this.dataArray) {
            for (var rowIndex=0; rowIndex<this.dataArray.length; rowIndex++) {
                generatedData.addObject(this.dataArray[rowIndex]);
            }
        } else if (this._useDataSource && this.dataSource) {
            var numberOfRows = this.dataSource.numberOfRows();

            for (var rowIndex=0; rowIndex<numberOfRows; rowIndex++) {
                var rowRepresentation = null;
                
                if (this.dataSource.objectForRow) {
                    rowRepresentation = this.dataSource.representationForRow(rowIndex);
                    
                    if (rowRepresentation && DC.typeOf(rowRepresentation) == "object") {
                        DC.KVO.adaptTree(rowRepresentation);
                    }
                }
                
                generatedData.addObject(rowRepresentation);
            }
        }
        
        if (!dashcode.inDesign && generatedData && generatedData.length && this.getSelectionEnabled() && !this.getAllowsEmptySelection()) {
            if (builtInArrayController.selectionIndex() == -1) {
                builtInArrayController.setSelectionIndex(0);
            }
        }
        
        // show the list after the data is loaded
        if (dashcode.inDesign) {
            var self = this;
            setTimeout(function() {if(self.viewElement()) { self.viewElement().style.display = "block";}}, 0);
        } else {
            this.viewElement().style.display = "block";
        }
                      
        // if it is inside a scroll area, notify it of the change
        if (typeof(AppleScrollArea) != "undefined") {
            var scrollElement = list.parentNode;
            while (scrollElement && scrollElement != document) {
                if (scrollElement.object && scrollElement.object.constructor == AppleScrollArea) {
                    scrollElement.object.refresh();
                    break;
                }
                scrollElement = scrollElement.parentNode;
            }
        }
    
    },
    
    createElement: function(relativeSource, beforeNode, container, index)
    {
        var row = this.base(relativeSource, beforeNode, container, index);
            
        if (dashcode.inDesign && (index == 0) && (row != this.templateElement)){
            container= container || this.container();
             container.insertBefore(this.templateElement,container.firstChild);        
            container.removeChild(row);
            if(row.parentNode){
                row.parentNode.removeChild(row);
            }
            this.templateElement.objectValue = row.objectValue;
            row = this.templateElement;
            DC.View.createViewsForNodeTree(row, null , this.__context)
            this.elementUsedForIndex(row,index);
        }
        
        return row;
    },
    
    highlightSelectionIndexes: function(selectionIndexes)
    {
        if (dashcode.inDesign)
            return;
        
        this.base(selectionIndexes);
    },
    
    elementUsedForIndex: function(row, index)
    {
        if (index == -1) {
            // unhighlight any rows not in use anymore
            this._setRowHighlighted(row, false, false);
            this.rows.removeObject(row);
            return;
        } else {
            while(index >= this.rows.length) {
                this.rows.addObject(null);
            }
            this.rows[index] = row;
        }
        
        if (!("object" in row)){
            row.object = {};
        }
        
        if (this._listStyle == DC.List.ROUNDED_RECTANGLE) {
            row.style.borderTopWidth = index > 0 ? "1px" : "0px";
        }
        
        if (this._useDataSource) {
            if (this.dataSource && this.dataSource.prepareRow) {
                this.dataSource.prepareRow(row, index, row.object.templateElements);
            }
        } else if (this.dataArray){
            if (row != this.templateRowElement && row.object) {
                row.object.index = index;
                row.object.value = this.dataArray[index];
            }
            
            // If static list
            this._prepareStaticRow(row,index,row.object.templateElements);
        }
        
        if (row.onclick) {
            var self = this;
            var originalHandler = null;

            row.object.clickHandler = row.onclick;
            if (row != this.templateRowElement)
                row.onclick = null;
            row.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
            row.style.webkitTouchCallout = "none"; 
        }                        
    },
    
    
    // --------- Selection ----------------- //
    
    //
    // Set the selection indexes. Optionally, animate the change.
    //
    setSelectionIndexes: function(newSelection, animated)
    {
        var oldSelection = this._selectionIndexes;
        
        if (!this._selectionEnabled) {
            return;
        }

        if (dashcode.inDesign)
            return;
        
        this._animateHighlight = animated;
        
        // call super to update internal state and bindings
        this.base(newSelection);
        
        delete this._animateHighlight;
        
    },
    
    highlightSelection: function(item,highlight)
    {
        this.base(item,highlight);
        this._setRowHighlighted(item, highlight, this._animateHighlight);
    },
    
    clearSelection: function(animated)
    {
        this.setSelectionIndexes([], animated);
    },
    
    _findRow: function(child)
    {  
        if (!child){
            return null;
        }
        var parent = child.parentNode;
        
        if (this.viewElement() == parent) {
            return child;
        }
        
        return this._findRow(parent);
    },
    
    onmousedown: function(event)
    {
        if (DC.Support.Touches) {
            // first use the row found during touch start
            var realTarget = this._touchedRow;
            // if none, find it now
            if (!realTarget) {
                realTarget = this._findRow(event.target ? event.target : event.srcElement);            
            }
            
            if (realTarget && !realTarget.object._highlighted && this._selectionEnabled){
                this._setRowHighlighted(realTarget, true, false);
                this._temporaryHighlight = realTarget;
            }
        }
        this.base(event);
    },
    
    onmouseup: function(event)
    {
        if (DC.Support.Touches) {
            if (this._temporaryHighlight){
                this._setRowHighlighted(this._temporaryHighlight, false, false);
                delete this._temporaryHighlight;
            }
        }
        
        this.base(event);
    },
    
    onclick: function(event)
    {
        var targetRow = this._temporaryHighlight;
        this.base(event);
                
        if (!this.action){
            if (!targetRow)
                targetRow = this._findRow(event.target ? event.target : event.srcElement);
            
            if (targetRow && targetRow.object && targetRow.object.clickHandler) {
                this._sendLegacyOnClick(event,targetRow,targetRow.object.clickHandler);
            }
        }        
  
        delete this._temporaryHighlight;
    },
    
    onswipe: function(event)
    {
        // set a swipe callback if the datasource defines one
        if (this.dataSource && this.dataSource.rowSwiped) {
            var targetRow = this._findRow(event.target ? event.target : event.srcElement);
            
            this.dataSource.rowSwiped(targetRow,event,5);
        }

    },
    
    // --------- Private methods ----------------- //
    
    
    _prepareStaticRow: function(rowElement,rowIndex,templateElements)
    {
        var labelElement = null;
        var data = this.dataArray[rowIndex];

        if (dashcode.inDesign && !templateElements){
            labelElement = document.getElementById(this._labelElementId);
        }
        
        for (var key in templateElements) {
            // try to find the label element
            if (this._labelElementId && this._labelElementId.length > 0 && key.indexOf(this._labelElementId) == 0) { 
                labelElement = templateElements[key];
                break;
            }
        }
        
        if (this._labelElementId && this._labelElementId.length && (rowElement == this.templateElement)) {
            var query = Element.queryAll(rowElement,"#" + this._labelElementId);
            
            if (query.length > 0)
                labelElement = query[0];
        }
        
        // get the text and value
        var itemLabel = '';
        var itemValue = '';
        if ((data) instanceof Array) {
            if (data.length > 0) {
                itemLabel = data[0];
                if (data.length > 1) {
                    itemValue = data[1];
                }
            }
        }
        else {
            itemLabel = data;
            itemValue = itemLabel;
        }
        
        // assign the label and insert it
        if (labelElement) {
            var localizedLabel = dashcode.getLocalizedString(itemLabel);
            if (localizedLabel) {
                itemLabel = localizedLabel;
            }
                      
            labelElement.innerHTML = itemLabel;
        }

    },
    
    _builtInArrayController: function(createIfNecessary)
    {
        if (!("_builtInAC" in this)){
            // Set up built in Array Controller
            this._builtInAC = new DC.ArrayController();
            this._builtInAC.selectsInsertedObjects = false;
            this._builtInAC.setAvoidsEmptySelection(!this.getAllowsEmptySelection() && this.getSelectionEnabled() && !dashcode.inDesign);
            this.bindNameToKeyPath("content","*.arrangedObjects", this._builtInAC);
            this.bindNameToKeyPath("selectionIndexes","*.selectionIndexes", this._builtInAC);
            // If we have an id, register so we can bind
            if (this.id)
                this._builtInAC.registerWithName(this.id);
        }
        
        return this._builtInAC;
    },
    
    _setDataArray: function(dataArray)
    {
        this.dataArray = dataArray;
        this.reloadData();
    },

    _setSampleRows: function(numberOfRows)
    {
        this._sampleRows = numberOfRows;
        this.reloadData();
    },

    _setUseDataSource: function(useDataSource)
    {
        this._useDataSource = useDataSource;
        this.reloadData();
    },

    _setLabelElementId: function(newId)
    {
        this._labelElementId = newId;
        this.reloadData();
    },

    _setRowHighlighted: function(rowElement, highlight, animated)
    {
        if (!rowElement || !rowElement.object)
            return;
        
        if (highlight != rowElement.object._highlighted) {
            if (highlight) {
                if (this._rowHighlight){
                    // if this row still has no highlight element, create it
                    if (!rowElement.object.rowHighlight) {
                        rowElement.object.rowHighlight = this._rowHighlight.cloneNode(true);
                        
                        var rowIndex = rowElement.object.index;
                        if (this._listStyle == DC.List.ROUNDED_RECTANGLE && (rowIndex == 0 || rowIndex == rowElement.parentNode.children.length-1) ) {
                            // Add rounded corners to the rowHighlight if it is in the first or last row.
                            var ULStyle = Element.getStyles(this.viewElement(), ["border-top-width", "border-bottom-width", "-webkit-border-top-left-radius", "-webkit-border-top-right-radius", "-webkit-border-bottom-left-radius", "-webkit-border-bottom-right-radius"]);
                            var rowStyle = rowElement.object.rowHighlight.style;
                            
                            // First Row.
                            if(rowIndex == 0){
                                var borderWidth = parseInt(ULStyle["border-top-width"], 10);
                                rowStyle.webkitBorderTopLeftRadius = (parseInt(ULStyle["-webkit-border-top-left-radius"], 10) - borderWidth) + "px";
                                rowStyle.webkitBorderTopRightRadius = (parseInt(ULStyle["-webkit-border-top-right-radius"], 10) - borderWidth) + "px";
                            }
                            // Last row. Note that it can be the same as the first row.
                            if(rowIndex == rowElement.parentNode.children.length-1){
                                var borderWidth = parseInt(ULStyle["border-bottom-width"], 10);
                                rowStyle.webkitBorderBottomLeftRadius = (parseInt(ULStyle["-webkit-border-bottom-left-radius"], 10) - borderWidth) + "px";
                                rowStyle.webkitBorderBottomRightRadius = (parseInt(ULStyle["-webkit-border-bottom-right-radius"], 10) - borderWidth) + "px";
                            }
                        }
                    }
                    // show it
                    var rowHighlight = rowElement.object.rowHighlight;
                    rowHighlight.style.opacity = 0;
                    rowElement.insertBefore(rowHighlight, rowElement.firstChild);
                    if (animated) {
                        rowHighlight.style.webkitTransitionProperty = 'opacity';
                        rowHighlight.style.webkitTransitionDuration = '.25s';
                        window.setTimeout(function() {
                            rowHighlight.style.opacity = 1;
                        }, 0);
                    } else {
                        rowHighlight.style.webkitTransitionProperty = 'none';
                        rowHighlight.style.webkitTransitionDuration = '0s';
                        rowHighlight.style.opacity = 1;                        
                    }
                    Element.addClassName(rowElement, DC.Style.kSelectedClass);
                }
            } else {
                var rowHighlight = rowElement.object.rowHighlight;

                // hide the highlight element
                if (rowHighlight){
                    if (animated) {
                        rowHighlight.style.webkitTransitionProperty = 'opacity';
                        rowHighlight.style.webkitTransitionDuration = '.25s';
                        var removeHighlight = function() {
                            rowElement.removeChild(rowHighlight);
                            Event.stopObserving(rowHighlight, 'webkitTransitionEnd', arguments.callee);
                        };
                        Event.observe(rowHighlight, 'webkitTransitionEnd', removeHighlight);
                        window.setTimeout(function() {
                            rowHighlight.style.opacity = 0;
                        }, 0);
                    } else {
                        rowHighlight.style.webkitTransitionProperty = 'none';
                        rowHighlight.style.webkitTransitionDuration = '0s';
                        rowHighlight.style.opacity = 0;
                    }                    
                    Element.removeClassName(rowElement, DC.Style.kSelectedClass);
                }
            }
            rowElement.object._highlighted = highlight;
        }
    }    
});

// Constants for the list types
DC.List.EDGE_TO_EDGE = 1;
DC.List.ROUNDED_RECTANGLE = 2;
DC.List.DESKTOP = 3;

if (!window.List) {
    window.List = DC.List;
}