/*jsl:import DashcodePart.js*/

/**   
 *  @declare DC.Browser
 *  @extends DC.DashcodePart
 *  
 */
 
/* 
 This file was generated by Dashcode and is covered by the 
 license.txt included in the project.  You may edit this file, 
 however it is recommended to first turn off the Dashcode 
 code generator otherwise the changes will be lost.
 */

// Public properties:
//    willGoToViewCallback: function to call when the browser will navigate to a view
//        The callback function will receive 4 parameters: (browser, oldView, newView, isBack)
//            browser: The browser that is performing the transition
//            oldView: The view element the browser is navigating from
//            newView: The view element the browser will navigate to
//            isBack:  true when the browser will navigate back
//    didGoToViewCallback: function to call when the transition for navigating to a view ended
//        The callback function will receive 4 parameters: (browser, oldView, newView, isBack)
//            browser: The browser that performed the transition
//            oldView: The view element the browser is navigating from
//            newView: The view element the browser navigated to
//            isBack:  true when the browser navigated back
//
// Public Methods:
//    getCurrentView(): returns the currently visible view element.
//    getCurrentTitle(): returns the currently visible title.
//    goForward(toView, title, backHandler): navigate forward to another view using a "right to left push" animation.
//        toView: the id of the view element (or the element itself) to navigate to. Must be a view of the stack layout.
//        title: the new title for the browser after the transition.
//        backHandler: callback function to execute when the user presses the 'back' button to navigate back.
//    goBack: navigate back to the previous view using a "left to right push" animation.
//    get/setClearSelectionOnBack: when this option is set to true, the browser will call clearSelection(true) on all the child parts of the destination view after navigating back. The 'true' parameter should be interpreted to control animation.
//


// Note: Properties and methods beginning with underbar ("_") are considered private and subject to change in future Dashcode releases.

DC.Browser= Class.create(DC.DashcodePart, {

    __viewClassName__: "Browser",

    partSetup: function(spec)
    {
        this.base(spec);

        this._clearSelectionOnBack = spec.clearSelectionOnBack || false;

        // Browser is usually pretty shallow from <body>
        this._topPosFromBody = 0;
        var curElement = this.viewElement();
        do {
            this._topPosFromBody += curElement.offsetTop;
        } while (curElement = curElement.offsetParent);
    },
    
    finishLoading:  function()
    {
        // Find the header and content elements.
        for (var child = this.viewElement().lastChild; child != null; child = child.previousSibling) {
            if (child.nodeType != 1/*Node.ELEMENT_NODE*/) {
                continue;
            }
            if (!this._contentElement) {
                if (child.object instanceof DC.StackLayout) {
                    this._contentElement = child;
                    this._contentElement.object._setRestrictToBrowserTransition(true);
                }
            } else if (!this._headerElement) {
                 if (child.object instanceof DC.Header) {
                    this._headerElement = child;
                }
            }
        }
    },
    
    getCurrentView:  function()
    {
        return this._contentElement.object.getCurrentView();
    },
    
    getCurrentTitle:  function()
    {
        return this._headerElement.object._getCurrentTitle();
    },
    
    goForward:  function(toView, title, backHandler)
    {
        var self = this;
        var prevView = this._contentElement.object.getCurrentView();
        var callback = function() {
            // Set timing and duration of header to match back transition
            var transition = self._contentElement.object.getTransitionForView(toView);
            if (transition) {
                var duration = (transition.type != Transition.NONE_TYPE) ? parseFloat(transition.getDuration()) : 0;
                self._headerElement.object._setAnimationDuration(duration);
                self._headerElement.object._setAnimationTiming(transition.timing);        
            }
            if (backHandler) {
                backHandler();   
            }
            
            // if specified, execute the public callback
            if (self.willGoToViewCallback) {
                self.willGoToViewCallback(self, prevView, toView, true);
            }
            self._contentElement.object._privateEndTransitionCallback = function(stackLayout, oldView, newView) {
                self._navigationDidEnd(oldView, newView, true);
            }
            
            self._backButtonClicked(prevView);
        }
        
        // Set timing and duration of header to match forward transition
        var transition = this._contentElement.object.getTransitionForView(toView);
        if (transition) {
            var duration = (transition.type != Transition.NONE_TYPE) ? parseFloat(transition.getDuration()) : 0;
            this._headerElement.object._setAnimationDuration(duration);
            this._headerElement.object._setAnimationTiming(transition.timing);        
        }
        
        // Show the top of the browser during when going forward so that visually, it shows the navigation to the user
        var scrollY = this._topPosFromBody - window.pageYOffset;
        if (scrollY < 0) {
            window.scrollBy(0, scrollY);
        }
        
        // if specified, execute the public callback
        if (this.willGoToViewCallback) {
            this.willGoToViewCallback(this, prevView, toView, false);
        }
        var self = this;
        this._contentElement.object._privateEndTransitionCallback = function(stackLayout, oldView, newView) {
            self._navigationDidEnd(oldView, newView, false);
        }
        
        this._contentElement.object._maskContainerElement = this.viewElement();
        // Let's do contentElement first since it is usually heavier
        this._contentElement.object.setCurrentView(toView);
        
        this._headerElement.object._goForward(title, callback);
    },
    
    goBack: function()
    {
        return this._headerElement.object._goBack();
    },
    
    getClearSelectionOnBack: function() 
    {
        return this._clearSelectionOnBack;
    },
    
    setClearSelectionOnBack: function(newValue)
    {
        this._clearSelectionOnBack = newValue;
    },
    

    _backButtonClicked:  function(toView)
    {
        this._contentElement.object._maskContainerElement = this.viewElement();
        this._contentElement.object.setCurrentView(toView, true);
    },
    
    _navigationDidEnd: function(fromView, toView, isBack)
    {
        // clear selection if necessary
        if (isBack && this._clearSelectionOnBack) {
            var child = toView.firstChild;
            while (child) {
                if (child.object && child.object.clearSelection) {
                    child.object.clearSelection(true);
                }
                child = child.nextSibling;
            }
        }
        
        // execute the public callback
        if (this.didGoToViewCallback) {
            this.didGoToViewCallback(this, fromView, toView, isBack);
        }
    }
    
});
